'''
В этом уроке мы с вами попробуем создать надстройку в нашей программе.
Представим, что мы разработали несколько алгоритмов сортировки, хотя на самом деле они уже существуют.
Однако будем считать себя их авторами.
Наша цель — сделать так, чтобы другие участники проекта могли использовать эти алгоритмы сортировки.
 Поэтому логично выделить отдельный файл, куда мы вынесем написанный код, чтобы его можно было распространять и использовать в будущем.
Приступим к реализации. В качестве примера мы напишем два алгоритма сортировки:
пузырьковую сортировку и сортировку выбором.
Следует отметить, что данные алгоритмы не являются идеальными; мы рассматриваем их как учебные примеры, поскольку они достаточно просты для понимания.
'''

nums = [5,6,12,4,7,1,9,44]

def buble_sort(ls):
    '''
    Пузырьковая сортировка работает следующим образом: сначала берутся первые два элемента массива и сравниваются между собой.
    Если первый элемент больше второго (или меньше, в зависимости от условий), они меняются местами.
    Затем алгоритм продолжает сравнивать и менять местами следующие пары элементов.
    Однако одного прохода по списку недостаточно, чтобы убедиться, что массив полностью отсортирован,
    поэтому требуется несколько таких проходов.
    Для пузырьковой сортировки сложность составляет «O(n²)», что означает,
    что количество операций возрастает квадратично по мере увеличения числа элементов.
    :param ls:
    :return:
    '''
    swapped = True # Отслеживает, были ли перестановки во время прохода.
    while swapped: # Этот цикл будет выполняться до тех пор, пока происходят перестановки элементов.
        swapped = False #Если в ходе прохода не было изменений, переменная «swapped» останется равной «False», и мы выйдем из цикла.
        for i in range(len(ls) - 1):#Если мы будем обращаться к индексу, когда находимся на предпоследнем и последнем элементах, и не сделаем «- 1»,
                                        # то получим ошибку при обращении к несуществующему элементу
            if ls[i] > ls[i+1]:
                ls[i], ls[i+1] = ls[i+1], ls[i]#если элемент списка с индексом «i» больше, чем элемент списка с индексом «i + 1».
                                                # В этом случае мы берём два соседних элемента и меняем их местами.
                swapped = True

# print(nums)
# buble_sort(nums)#функция не возвращает отсортированный список как новый объект, а просто изменяет исходный список на месте, меняя местами его элементы
# print(nums)

def selection_sort(ls):
    '''
    Принцип работы этого алгоритма основан на разделении списка на две части: отсортированную и неотсортированную.
    Мы будем перебирать все элементы в неотсортированной части и находить минимальный элемент,
    который затем переместим в отсортированную часть списка.
    :param ls:
    :return:
    '''
    for i in range(len(ls)):
        lowest = i #Мы будем считать, что первый элемент в списке — это самый маленький элемент, назначим переменной «lowest» значение «i», чтобы получить индекс самого маленького элемента
        for j in range(i+1, len(ls)):#Пройдемся по неотсортированной части списка, начиная с элемента «i + 1»
            if ls[j] < ls[lowest]:#Сравним каждый элемент неотсортированной части с текущим минимальным элементом
                lowest = j#Обновим значение lowest
        ls[i], ls[lowest] = ls[lowest], ls[i]

# print(nums)
# selection_sort(nums)
# print(nums)
